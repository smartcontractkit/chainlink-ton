package tonutils

import (
	"context"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/xssnick/tonutils-go/address"
	"github.com/xssnick/tonutils-go/tlb"
	"github.com/xssnick/tonutils-go/ton"
	"github.com/xssnick/tonutils-go/ton/wallet"
	"github.com/xssnick/tonutils-go/tvm/cell"
)

// SignedAPIClient provides a high-level interface for interacting with the TON blockchain.
// It wraps the low-level TON API client and wallet functionality to provide
// convenient messages for sending transactions, deploying contracts, and monitoring
// message flows.
type SignedAPIClient struct {
	Client ton.APIClientWrapped
	Wallet wallet.Wallet
}

func NewSignedAPIClient(client ton.APIClientWrapped, wallet wallet.Wallet) SignedAPIClient {
	return SignedAPIClient{
		Client: client,
		Wallet: wallet,
	}
}

// SendWaitTransaction sends a transaction to the specified address and waits for
// it to be confirmed on the blockchain. It returns the resulting ReceivedMessage
// with outgoing messages (if any) and the block sequence number where the
// transaction was included.
//
// This message only waits for the initial transaction confirmation, not for any
// outgoing messages to be processed. Use SendAndWaitForTrace for complete trace waiting.
func (c *SignedAPIClient) SendWaitTransaction(ctx context.Context, dstAddr address.Address, messageToSend *wallet.Message) (*ReceivedMessage, *ton.BlockIDExt, error) {
	tx, block, err := c.Wallet.SendWaitTransaction(ctx, messageToSend)
	if err != nil {
		return nil, nil, fmt.Errorf("deposit transaction failed for %s: %w", dstAddr.String(), err)
	}

	receivedMessage, err := MapToReceivedMessage(tx)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get outgoing messages: %w", err)
	}
	return &receivedMessage, block, nil
}

// SendAndWaitForTrace sends a transaction to the specified address and waits for
// the complete execution trace, including all outgoing messages and their
// subsequent outgoing messages recursively. It ensures that the entire message
// cascade has been processed and finalized before returning.
//
// The message returns the resulting message in a Finalized state, meaning all
// outgoing messages have been confirmed and processed.
func (c *SignedAPIClient) SendAndWaitForTrace(ctx context.Context, dstAddr address.Address, messageToSend *wallet.Message) (*ReceivedMessage, error) {
	sentMessage, block, err := c.SendWaitTransaction(ctx, dstAddr, messageToSend)
	if err != nil {
		return nil, fmt.Errorf("failed to SendWaitTransaction: %w", err)
	}
	err = sentMessage.WaitForTrace(c)
	if err != nil {
		return nil, fmt.Errorf("failed to wait for trace: %w", err)
	}
	master, err := c.Client.WaitForBlock(block.SeqNo).CurrentMasterchainInfo(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get masterchain info for funder balance check: %w", err)
	}

	for {
		// Check if the block is ready
		if master.SeqNo > block.SeqNo+1 {
			break
		}
		time.Sleep(time.Millisecond * 500)
		master, err = c.Client.WaitForBlock(block.SeqNo).CurrentMasterchainInfo(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to get masterchain info for funder balance check: %w", err)
		}
	}

	return sentMessage, nil
}

// SubscribeToTransactions returns a channel with all incoming transactions for
// the given address that came after lt (Lamport Time). It will work
// retroactively, so it will return all transactions that are already in the
// blockchain and all new ones.
func (c *SignedAPIClient) SubscribeToTransactions(address address.Address, lt uint64) chan *tlb.Transaction {
	transactionsReceived := make(chan *tlb.Transaction)

	// it is a blocking call, so we start it asynchronously
	go c.Client.SubscribeOnTransactions(context.Background(), &address, lt, transactionsReceived)
	return transactionsReceived
}

// CompiledContract represents a compiled TON smart contract with its code,
// ABI definition, and metadata. This structure is typically loaded from
// the JSON files generated by the TON compiler.
type TactCompiledContract struct {
	Name string `json:"name"`
	Code string `json:"code"`
	Abi  string `json:"abi"`
}

type TolkCompiledContract struct {
	Hash       string `json:"hash"`
	HashBase64 string `json:"hashBase64"`
	Hex        string `json:"hex"`
}

type compiledContract interface {
	CodeCell() (*cell.Cell, error)
}

func (c TactCompiledContract) CodeCell() (*cell.Cell, error) {
	// Extract the Base64-encoded BOC
	codeBoc64 := c.Code
	if codeBoc64 == "" {
		return nil, fmt.Errorf("codeBoc64 field is empty in the JSON")
	}

	// Decode the Base64 string to get the actual BOC binary
	codeBocBinary, err := base64.StdEncoding.DecodeString(codeBoc64)
	if err != nil {
		return nil, fmt.Errorf("Failed to decode base64: %v", err)
	}

	// Parse the BOC binary into a cell
	codeCell, err := cell.FromBOC(codeBocBinary)
	if err != nil {
		return nil, fmt.Errorf("Failed to parse BOC binary: %v", err)
	}
	return codeCell, nil
}

func (c TolkCompiledContract) CodeCell() (*cell.Cell, error) {
	// Extract the Hex-encoded BOC
	codeBocHex := c.Hex
	if codeBocHex == "" {
		return nil, fmt.Errorf("codeBocHex field is empty in the JSON")
	}

	// Decode the Hex string to get the actual BOC binary
	codeBocBytes, err := hex.DecodeString(codeBocHex)
	if err != nil {
		return nil, fmt.Errorf("Failed to decode hex: %v", err)
	}

	// Parse the BOC binary into a cell
	codeCell, err := cell.FromBOC(codeBocBytes)
	if err != nil {
		return nil, fmt.Errorf("Failed to parse BOC binary: %v", err)
	}
	return codeCell, nil
}

// Deploy deploys a contract to the blockchain. It takes the path to the
// compiled contract JSON file generated by the Tact compiler and the initial data
// for the contract. It returns the address of the deployed contract and waits for
// the deployment to be fully confirmed.
//
// The function returns an error if the deployment fails, including cases where
// the contract compilation fails, the deployment transaction fails, or the
// deployment exit code indicates failure.
// TODO this is Tact specific. Should migrate to Tolk output
func (c *SignedAPIClient) Deploy(codeCell *cell.Cell, initData *cell.Cell, amount tlb.Coins) (*Contract, error) {
	// Create empty message body for deployment
	msgBody := cell.BeginCell().EndCell()

	// Deploy the contract
	addr, tx, _, err := c.Wallet.DeployContractWaitTransaction(
		context.Background(),
		amount,
		msgBody,
		codeCell,
		initData,
	)
	if err != nil {
		return nil, fmt.Errorf("deployment failed: %v", err)
	}

	receivedMessage, err := MapToReceivedMessage(tx)
	if err != nil {
		return nil, fmt.Errorf("failed to get outgoing messages: %w", err)
	}
	err = receivedMessage.WaitForTrace(c)
	if err != nil {
		return nil, fmt.Errorf("failed to wait for trace: %w", err)
	}
	if receivedMessage.ExitCode != ExitCode_Success || len(receivedMessage.OutgoingInternalReceivedMessages) != 1 {
		return nil, fmt.Errorf("contract deployment failed: error sending external message: exit code %d: %s", receivedMessage.ExitCode, receivedMessage.ExitCode.Describe())

	}
	deployExitCode := receivedMessage.OutgoingInternalReceivedMessages[0].ExitCode
	if !deployExitCode.IsSuccessfulDeployment() {
		return nil, fmt.Errorf("contract deployment failed: exit code %d: %s", deployExitCode, deployExitCode.Describe())
	}

	return &Contract{addr, c}, nil
}

func CompiledContract(path string) (*cell.Cell, error) {
	compiledContract, err := getCompiledContract(path)
	if err != nil {
		return nil, fmt.Errorf("Failed to compile contract: %v", err)
	}

	// Parse the BOC binary into a cell
	codeCell, err := compiledContract.CodeCell()
	if err != nil {
		return nil, fmt.Errorf("Failed to parse BOC binary: %v", err)
	}
	return codeCell, nil
}

// getCompiledContract reads and parses a compiled contract JSON file.
// It validates that the contract file exists and contains the required
// fields (Name, Code, Abi). Returns a CompiledContract struct or an error
// if the file cannot be read or parsed.
func getCompiledContract(contractPath string) (compiledContract, error) {
	// Check if contract file exists
	if _, err := os.Stat(contractPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("Contract file not found: %s", contractPath)
	}
	jsonData, err := os.ReadFile(contractPath)
	if err != nil {
		return nil, fmt.Errorf("Failed to read compiled contract: %v", err)
	}

	if strings.HasSuffix(contractPath, ".pkg") {
		// Parse the JSON
		compiledContract := &TactCompiledContract{}
		err = json.Unmarshal(jsonData, &compiledContract)
		if err != nil {
			return nil, fmt.Errorf("Failed to parse JSON: %v", err)
		}
		return compiledContract, nil
	} else if strings.HasSuffix(contractPath, ".compiled.json") {
		// Parse the JSON
		compiledContract := &TolkCompiledContract{}
		err = json.Unmarshal(jsonData, &compiledContract)
		if err != nil {
			return nil, fmt.Errorf("Failed to parse JSON: %v", err)
		}
		return compiledContract, nil
	} else {
		return nil, fmt.Errorf("Unsupported contract file format: %s", contractPath)
	}
}
